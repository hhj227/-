# 기초부터 다지는 ElasticSearch 운영 노하우



## 11장 검색 성능 최적화



## 1.1. ElasticSearch 캐시의 종류와 특성



동일한 요청 빠르게 처리 -> 캐시 이용

이 때 사용하는 메모리 영역 -> 메모리 캐시



#### 캐시의 종류

##### 11.1.1. Node Query Cache (qcm: query cache memory)

Node 단위로 캐시가 이루어짐

Query 중 `Filter query` 만 캐시됨



##### 캐싱 원리

filter context로 구성된 쿼리로 검색하면 내부적으로 각 문서에 bitset(0,1) 설정

호출된 적이 있다면 1로 설정

사용자의 쿼리 횟수와 1인 문서들 사이에 연관관계 확인

그 중 자주 호출되었다고 판단한 문서들을 노드의 메모리에 캐싱 ( => 문서 자체를 cache 하는 것이 아니라, 필터쿼리와 각 문서의 매칭이 `true`, `false` 인지만 `bitset` 형태로 저장)

⚠️ 세그먼트 하나에 저장된 문서의 수가 10000개 미만이거나 검색 쿼리가 인입되고 있는 인덱스가 전체 인덱스 사이즈의 3% 미만일 경우에는 캐싱되지 않음



```json
```



⚠️ node query cache 설정은 dynamic setting이 아니어서 인덱스를 close로 바꾸고 설정해야 한다.



##### 캐싱된 문서 삭제 방법

캐시 메모리 영역이 가득 차면 LRU 알고리즘에 의해 삭제



###### node query cache 영역 조정하는 법

```json
// elasticsearch.yml 파일
indices.queries.cache.size: 10%
```

512MB와 같이 절대값을 줄 수도 있다.



속도가 빠르고 cache 가 되므로, 다른 쿼리에 앞서 실행해 주는것이 성능향상에 도움이 됩니다.

cache 는 현재의 쿼리 뿐만 아니라 다른 쿼리에서도 재사용됩니다.

filter cache 에 할당되는 메모리 사이즈는 디폴트값이 JVM HEAP 사이즈의 10% 입니다.



##### 11.1.2. Shard Request Cache (rcm: request cache memory)

샤드를 대상으로 캐싱

특정 필드에 의한 검색 -> 전체 샤드에 캐싱됨

`"size": 0` 일 때, 다시 말해 문서를 리턴받지 않고 집계 데이터만 사용할때 캐싱



###### node query cache  VS  Shard Request Cache

<활용도>

전자는 검색 엔진에서 활용하기 적합

후자는 분석 엔진에서 활용하기 적합

<설정값 변경>

전자는 dynamic setting X

후자는 dynamic setting O (운영 중에도 바로 변경 가능)



shard 내의 문서에 변화가 생기거나 refresh하면 모든 cache 는 무효화. 때문에, 문서의 변화가 거의 없는 정적인 shard 에서 사용하는 것이 좋다. (캐싱 데이터를 유지하기 위해서 read-only 처리한다.)





shard cache 에 할당되는 메모리 사이즈는 디폴트로 JVM HEAP 사이즈의 1% 입니다.

elasticsearch.yml 에 `indices.requests.cache.size` 로 설정해야 합니다.



##### 11.1.3. Field Data Cache

인덱스를 구성하는 필드에 대한 캐싱

주로 검색 결과를 정렬하거나 집계 쿼리를 수행할 때 사용 (통계 데이터 생성)

지정한 필드만을 대상으로 해당 필드의 모든 문서를 메모리에 저장하는 캐싱 영역 (=> 메모리를 많이 사용할 수 있어서 사전에 충분한 메모리를 확보하는 것이 좋다)

⚠️ text 필드 데이터 타입은 기본적으로 캐싱 허용하지 않음. 큰 데이터가 저장되기 때문.



elasticsearch.yml 에 `indices.fielddata.cache.size` 로 설정해야 합니다. 하지만, `Field Data Cache` 는 할당량을 제한해도 작동방식이 먼저 메모리에 데이타를 올리고 제한을 넘으면 사용되지 않는 데이타를 제거하는 방식이기에 `OOM` 에러가 발생할 수 있습니다.



출처: https://www.skyer9.pe.kr/wordpress/?p=1070



##### 11.1.4. 캐시 영역 클리어



```json
POST {index}/_cache/clear?query=true
POST {index}/_cache/clear?request=true
POST {index}/_cache/clear?fielddata=true
```



_all로 전체 캐시 클리어할 수도 있다. 

불필요한 캐시 데이터를 저장하는 것보다 캐시 데이터를 삭제하면서 운영하는게 성능 면에서 유리하다



### 11.2. 검색 쿼리 튜닝하기

###### <방법 1> copy_to

너무 많은 필드 사용하면 검색 성능 떨어진다.

많은 필드를 하나의 필드로 모아서 검색할 수 있는 기능





```json
PUT my-index-000001
{
  "mappings": {
    "properties": {
      "first_name": {
        "type": "text",
        "copy_to": "full_name" 
      },
      "last_name": {
        "type": "text",
        "copy_to": "full_name" 
      },
      "full_name": {
        "type": "text"
      }
    }
  }
}

PUT my-index-000001/_doc/1
{
  "first_name": "John",
  "last_name": "Smith"
}

GET my-index-000001/_search
{
  "query": {
    "match": {
      "full_name": { 
        "query": "John Smith",
        "operator": "and"
      }
    }
  }
}
```



last_name, first_name 필드의 값을 full_name이라는 새로운 필드로 복사해서 두 필드의 값을 한번에 검색

bool 쿼리 -> 단일 쿼리



###### <방법 2> match보단 term 



match 쿼리는 query context에 속하는 쿼리 -> analyzer를 통해 분석하는 과정이 포함돼서 시간이 더 걸림

term 쿼리는 filter context -> 분석 X -> 성능이 더 좋음



또, ES에서는 수치 계산이 없는 숫자형 데이터는 keyword 필드 데이터 타입으로 매핑하도록 권고

-> filter context를 통해 문서 캐싱하기에도 좋아서 검색 성능에 도움이 됨



### 11.3. 샤드 배치 결정하기



처음에 샤드 개수 한번 설정하면 변경할 수 없기 때문에 신중하게 설정해야 한다.



샤드 배치 잘못해서 생길 수 있는 문제 예시

- 데이터 노드 간 디스크 사용량 불균형
- 색인/검색 성능 부족
- 데이터 노드 증설 후에도 검색 성능이 나아지지 않음
- 클러스터 전체의 샤드 개수가 지나치게 많음



###### BAD CASE

노드 간 볼륨 사용량 불균형 문제 -> 노드1만 디스크 사용량 높아짐

---

0 3

1

2

노드 개수보다 샤드를 적게 설정한 경우 -> 색인/검색에 참여 못하는 노드

---

0

1

-

노드 개수보다 샤드를 적게 설정한 경우 인덱스가 추가될 때 -> 특정 노드가 샤드를 배치받지 못하는 상황 유지

---

0|

1|1

  |0

클러스터에 노드를 증설한 경우 -> 할당할 샤드가 없기 때문에 증설 효과 느낄 수 없음

---

0

1

2

-

샤드의 개수를 노드의 N배수로 설정한 상황에서 노드 한 대를 추가했을 경우 -> 노드 간 볼륨 사용량 불균형 발생

---

0 3

1 4

2 5

⬇️

0 

1 4

2 5

3 

최소 공배수로 설정한 샤드의 경우 -> 각각의 노드가 가지고 있는 4개의 샤드 중 한 개씩 재분배

---

0 3 6 9

1 4 7 10

2 5 8 11

⬇️

0   6 9

1 4   10

2 5 8 

3   7 11





클러스터 내에 샤드가 많아지면 마스터 노드가 관리해야 하는 정보도 늘어남 -> 마스터 노드는 이 정보들을 관리하기 위해 할당된 힙 메모리를 점점 더 많이 사용



데이터 노드의 사용량은 많지 않은데 클러스터의 성능이 제대로 나오지 않는다면 마스터 노드의 성능 확인 필요



하나의 노드에서 조회할 수 있는 샤드의 개수 제한하는 설정을 할 수 있음



### 11.4. forcemerge API 



세그먼트를 강제로 병합할 때 사용하는 API

⚠️ 무조건 세그먼트가 적다고 좋은 것은 아니다. 

샤드 하나의 크기가 100GB 정도인데 세그먼트가 하나라면 작은 크기의 문서를 찾을 때에도 100GB의 크기 전체를 대상으로 검색해야 해서 병합 전보다 성능 떨어질 수 있음

-> 따라서 하나의 샤드에 적절한 용량이 할당되도록 하고, 적절한 용량으로 병합하는게 중요

색인이 모두 끝난 인덱스는 병합 작업을 진행하고 난 이후 read-only 모드로 설정하여 더 이상 세그먼트가 생성되지 못하게 하는 것이 좋다.



### 11.5. 그 외의 검색 성능을 확보하는 방법들



##### 문서 모델링은 가급적 간결하게 구성

parent/child 구조의 join 구성, nested 같이 문서 간의 연결 관계 처리를 필요로 하는 구성 지양

painless script를 사용하여 하나의 문서를 처리할 때마다 부가적으로 리소스를 사용하지 않도록 하는 것 권고



다만, nested 타입에 저장될 데이터 의 개수가 유동적일 때는 성능 손실을 감수하고 사용할 수 밖에 없다.



##### 레플리카 샤드를 충분히 두기



데이터 안정성 확보 & 검색 요청에 대해 많은 샤드들이 결과를 리턴해주는 역할

다만, 인덱싱 성능과 볼륨 사용량의 낭비가 발생하니 클러스터의 용량을 고려해서 추가



### 11.6. 마치며

1. 캐시 영역 적절하게 활용
2. node query cache: 쿼리 결과를 각 노드에 캐싱
3. shard request cache: 쿼리 결과 중 집계 데이터에 관한 결과를 각 샤드에 캐싱
4. field data cache: 쿼리의 대상이 되는 필드의 데이터들을 캐싱
5. 검색할 대상 필드를 줄이거나 쿼리의 종류를 바꾸기
6. forcemerge API를 활용해서 색인이 끝난 인덱스의 샤드 내 세그먼트를 강제로 병합하면 성능 향상시킬 수 있음
7. 꼭 필요한 상황이 아니면 nested 타입과 같은 복잡한 형태의 데이터 타입 쓰지 말기
8. 클러스터 용량에 여유가 있다면 레플리카 샤드를 추가로 만들기







